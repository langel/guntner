
;;;; COLLISION DETECTOR
;	
;	works by putting object data into the following 0 page variables
;
;	collision_0_x	byte
;	collision_0_y	byte
;	collision_0_w	byte
;	collision_0_h	byte
;	collision_1_x	byte
;	collision_1_y	byte
;	collision_1_w	byte
;	collision_1_h	byte
;
;	returns ff (true) or 00 (false) in accumulator

detect_collision: subroutine
	clc
        lda collision_0_x
        adc collision_0_w
        bcs .no_collision ; make sure x+w is not less than x
        cmp collision_1_x
        bmi .no_collision
        clc
        lda collision_1_x
        adc collision_1_w
        cmp collision_0_x
        bmi .no_collision
        clc
        lda collision_0_y
        adc collision_0_h
        cmp collision_1_y
        bmi .no_collision
        clc 
        lda collision_1_y
        adc collision_1_h
        cmp collision_0_y
        bmi .no_collision
        lda #$ff
        rts
.no_collision
	lda #$00
        rts
        
    
        
player_collision_detect: subroutine
	clc
        lda collision_0_x
        adc collision_0_w
        bcs .done ; make sure x+w is not less than x
        cmp player_x_hi
        bmi .done ; no collision
        clc
        lda player_x_hi
        adc #$10 ; player width
        cmp collision_0_x
        bmi .done ; no collision
        clc
        lda collision_0_y
        adc collision_0_h
        cmp player_coll_y
        bmi .done ; no collision
        clc 
        lda player_coll_y
        adc #$06 ; player height
        cmp collision_0_y
        bmi .done ; no collision
; handle player collision
	lda enemy_dmg_accumulator
        clc
        adc #$02
        sta enemy_dmg_accumulator
        ; XXX this number is sus
        ; player sprites don't always change at death
        ldy enemy_ram_type,x
        lda ENEMY_PLAYER_COLLISION_TABLE,y
        ldy enemy_ram_oam,x
        sta player_damage
        jsr player_take_damage
        jsr apu_trigger_player_damage
.done
        rts
