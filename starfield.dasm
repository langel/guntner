;;;; Constants

STARFIELD_MASK		.byte #%00111111 ; star probability
STARFIELD_COL0_START	.byte #$00
STARFIELD_COL1_START	.byte #$07

starfield_tile	.byte #$0f
starempty_tile	.byte #$20
starfield_sprite	.byte	#$6b

starfield_msg_cache	=	$03e0	; 32 bytes for string data

star_cache		EQU 	208


;	POSSIBLE STARFIELD STATES
;	- basic bg scrolling
;	- basic sprite scrolling
;	- transitions
;		- bg to sprite
;		- sprite to bg


death_scroll_speed: subroutine
        lda scroll_speed
        cmp #$00
        beq .scroll_slow_done
	dec scroll_speed_m
        lda scroll_speed_m
        lsr
        lsr
        lsr
        sta scroll_speed
        ; slow down stars
.scroll_slow_done
	rts
        
        
starfield_draw_dash_top_bar_nametable0: subroutine
        ; fill page 1 bar for sprite 0 collisions
	PPU_SETADDR dash_page1_top_bar
        lda dash_top_bar_tile
        ldy #$20
.tile_dash_set_page1
        sta PPU_DATA
        dey
        bne .tile_dash_set_page1
        rts
        
        
starfield_scroll: subroutine
	; update scroll pos
	lda scroll_x
        sec
        sbc scroll_speed
        bcs .samepage
        inc scroll_page
        dec state_v7
.samepage
	sta scroll_x
 	; find starfield column for updating       
        lsr
        lsr
        lsr
        sta starfield_col
        ; set nametable for column updating
        lda scroll_page
        and #$01
        cmp #$00
        bne .scroll_page
        lda #$20
        sta starfield_page
   	jmp .scroll_page_done
.scroll_page
	lda #$24
        sta starfield_page
.scroll_page_done
        rts
        


starfield_debugger: subroutine
	; dash cache meter is $108-$118
        ; scroll page
        lda scroll_page
        and #1
        clc
        adc #$30
        sta $109
        ; scroll x position
        lda scroll_x
        lsr
        lsr
        lsr
        lsr
        clc 
        adc #$30
        sta $10b
        lda scroll_x
        and #$f
        clc
        adc #$30
        sta $10c
        ; scroll y position
        lda scroll_y
        lsr
        lsr
        lsr
        lsr
        clc 
        adc #$30
        sta $10e
        lda scroll_y
        and #$f
        clc
        adc #$30
        sta $10f
        ; starfield state
        lda starfield_state
        clc
        adc #$30
        sta $111
	rts
        
        
        
starfield_bg_render: subroutine
	; copy tiles to PPU VRAM during vblank
;update_starfield_column
        lda #CTRL_INC_32
        sta PPU_CTRL
        ; set base PPU address
	lda starfield_page
        sta PPU_ADDR
        lda starfield_col
        sta PPU_ADDR
; rip from cache to PPU
        ldy #$16
.col_loop
	lda star_cache,y
        sta PPU_DATA
        dey
        bne .col_loop
        ; put that shit back to sequential order
        lda #0
        sta PPU_CTRL
        jsr dashboard_render
        jmp state_render_done
        
        
phase_msg_tile_data:
	; XXX this definitely should not be done during render
        .hex 2107
        .byte "PHASE 1x COMPLETED"
        .byte #$00
        ; XXX might need another method for writing
        ;     one line at a time to nametable
        .hex 2147
        .byte "moar text for test"
        .byte #$00
        .byte #$ff
        .hex 2187
        .byte "no i won't shutup"
        .byte #$00
        .byte #$ff
        
starfield_spr_render: subroutine
	; XXX pretty sure this will never do a thing?
        ; maybe could be used to put messages on screen?
        NMTP_SETADDR phase_msg_tile_data
        jsr nametable_tile_planter
        jsr dashboard_render
        jmp state_render_done
        
        
        
starfield_bg2spr_render: subroutine
	; remove bg columns
        jmp state_render_done
        
        
starfield_spr2bg_render: subroutine
	; populate bg columns
        jmp state_render_done
        
        
        
   
starfield_bg_init: subroutine
; set starfield state
	lda #$00
        sta starfield_state
; set bg tile palette attributes / colors
; $23c0 and $27c0
        ; page 1 attributes
	PPU_SETADDR $23c0
	lda #%00010100
        ldx #$d8
.23c0_loop
        sta PPU_DATA
        inx
        bne .23c0_loop
        ; COLOR SPLIT
        ; set split color attr for top row
	PPU_SETADDR $23e8
	lda #%11110001
        ldx #$f8
.27e8_loop
        sta PPU_DATA
        inx
        bne .27e8_loop
        ; page 2 attributes
	PPU_SETADDR $27c0
	lda #%00010100
        ldx #$d8
.27c0_loop
        sta PPU_DATA
        inx
        bne .27c0_loop
        ; make sure sprite0 has something to collide with
        jsr starfield_draw_dash_top_bar_nametable0
; draw stars on nametable 1
        lda #CTRL_INC_32
        sta PPU_CTRL
        ;stx starfield_page
	ldx #$00
.draw_stars_loop
        stx starfield_col
        jsr get_next_random
        jsr starfield_cache_next_col
	lda #$20
        sta PPU_ADDR
        lda starfield_col
        sta PPU_ADDR
        ldy #$16
.transfer_loop
	lda star_cache,y
        sta PPU_DATA
        dey
        bne .transfer_loop
        inx
        cpx #$20
        bne .draw_stars_loop
        lda #0
        sta PPU_CTRL
	rts
        

        
        
        
        
        
                
STARFIELD_STATE_UPDATE_FUNCTION_TABLE:
	.word starfield_bg_update
	.word starfield_spr_update
        .word starfield_bg2spr_update
        .word starfield_sprmsg_update
        .word starfield_spr2bg_update
        
starfield_update: subroutine
	lda starfield_state
        asl
        tax
	lda STARFIELD_STATE_UPDATE_FUNCTION_TABLE,x
        sta temp00
        inx
	lda STARFIELD_STATE_UPDATE_FUNCTION_TABLE,x
        sta temp01
        jmp (temp00)




starfield_bg_update: subroutine
; will not work with scroll speeds above 8
	; precalculate all starfield things post sprite 
	jsr starfield_scroll
        ; twinkle them stars with palette stuff
        jsr starfield_twinkle_colors
        jsr starfield_twinkle_bg
	; XXX hook this up with tile changing later
        ; probably hearts after killing a boss
        ; XXX starfield_tile
        ; #$0f star
        ; #$90 heart
starfield_cache_next_col:
        ; setup rng for star probability
        lda rng0
        lsr
        and STARFIELD_MASK
        sta temp00
      	ldy #$00
.col_assign_tile_loop
	cpy temp00
        bne .empty_tile
.star_tile
	lda starfield_tile
        jmp .cache_tile
.empty_tile
	lda starempty_tile 
.cache_tile
	sta star_cache,y
        iny
        cpy #$16
        bne .col_assign_tile_loop
        rts
        
        
        
        
starfield_bg2psr_init: subroutine
        lda #2
        sta starfield_state
        ; distribute star sprites
	ldx #$80
        lda scroll_x
        and #7
        sta temp00
.loop
	sta oam_ram_x,x
        lda #$ff
        sta oam_ram_y,x
        lda #$08
        clc
        adc temp00
        sta temp00
        inx
        inx
        inx
        inx
        bne .loop
        ; log destination of nametable0 cleared
        lda scroll_x
        sta state_v6
        lda starfield_page
        cmp #$20
        bne .do_the_full_monty
        lda #1
        sta state_v7
	rts
.do_the_full_monty
	lda #2
        sta state_v7
        rts
        
        
starfield_bg2spr_update: subroutine
	; an initializer needs to set a counter for when
        ; nametable0 is cleared
        
        ; clear left col of nametable starfield
        lda #$20
        ldx #$16
.clear_col_loop
	sta star_cache,x
        dex
        bne .clear_col_loop
        
        ; setup left col of starfield sprite
        jsr starfield_spr_get_position
        jsr starfield_spr_set_next
       
	jsr starfield_scroll
        jsr starfield_spr_update
        ;jsr starfield_twinkle_colors
        jsr starfield_twinkle_bg
        ;jsr starfield_twinkle_spr
        
        ; check if nametable0 is cleared
        lda scroll_x
        cmp state_v6
        bcs .done
        lda state_v7
        cmp #0
        bne .done
        lda #3
        sta starfield_state
        lda #0
        sta scroll_x
        sta scroll_page
        sta state_v7
        lda #4
        jsr state_render_set_addr
.done	
	rts
        


        
        
starfield_spr_get_position: subroutine
        lda scroll_x
        lsr
        lsr
        lsr ; col position (range of 32)
        asl
        asl
        clc
        adc #$80
        tax ; oam ram offset
	; scroll_x decides which sprite and x position
        lda scroll_x
        and #$07 ; this is the x position
        sec
        sbc #8
        sta oam_ram_x,x
	rts
        
                
; XXX we might need this in the end?
starfield_spr_init: subroutine
	; set that state
	lda #$01
        sta starfield_state
        lda #$03
        jsr state_render_set_addr
        ; work with top half of sprites
	lda #$80
        sta temp00
        lda #$00
        sta temp01
.set_each_star
	; temp00 holds oam ram offset
        ; temp01 holds x position
        ldx temp00
        lda temp01
        sta oam_ram_x,x
        jsr starfield_spr_set_next
.forward_loop
        ; next loop
        lda #$08
        clc
        adc temp01
        sta temp01
        lda #$04
        clc
        adc temp00
        sta temp00
        bcc .set_each_star
        jsr nametables_clear
        jsr starfield_tile_left_border
	rts
        
        
starfield_spr_update: subroutine
        ; twinkle them stars with palette stuff
        jsr starfield_twinkle_colors
        jsr starfield_twinkle_spr
        ; cycle through all star sprites
	lda #$80
        sta temp00
.scroll_loop
	ldx temp00
        lda oam_ram_x,x
        clc
        adc scroll_speed
        sta oam_ram_x,x
        bcc .dont_update_star
        jsr starfield_spr_set_next
.dont_update_star
        lda #$04
        clc
        adc temp00
        sta temp00
        bcc .scroll_loop
	rts



starfield_sprmsg_table:
        .byte "       PHASE 1x COMPLETED       "	; 2100
        .byte "       moar text for test       "	; 2140
        .byte "       no i won't shutup        "	; 2180
        
starfield_sprmsg_render: subroutine
	; state_v7 is a state counter
        ; state_v0 nametable high address
        ; state_v1 nametable low address
        ; write from msg_cache to nametable
	lda state_v7
        cmp #0
        bne .not_tile_left_border
        jsr starfield_tile_left_border
        jmp state_render_done
.not_tile_left_border
	lda state_v1
        sta PPU_ADDR
	lda state_v0
        sta PPU_ADDR
        ldx #31
.sprmsg_loop
        lda starfield_msg_cache,x
        sta PPU_DATA
        dex
        bne .sprmsg_loop
        jsr dashboard_render
        jmp state_render_done


starfield_sprmsg_update: subroutine
        jsr starfield_spr_update
	lda state_v7
        asl
        tax
        lda starfield_msgscroll_setup_table,x
        sta temp00
        inx
        lda starfield_msgscroll_setup_table,x
        sta temp01
        inc state_v7
        jmp (temp00)
starfield_msgscroll_setup_table:
	.word starfield_msgscroll_setup_clear_msg_cache		; 0
        .word starfield_msgscroll_setup_clear_dash_space	; 1
        .word starfield_msgscroll_setup_clear_dash_space	; 2
        .word starfield_msgscroll_setup_clear_dash_space	; 3
        .word starfield_msgscroll_setup_clear_dash_space	; 4
        .word starfield_msgscroll_setup_clear_dash_space	; 5
        .word starfield_msgscroll_setup_clear_dash_space	; 6
        .word starfield_msgscroll_setup_populate_message	; 7
        .word starfield_msgscroll_setup_next_state
        
starfield_msgscroll_setup_clear_msg_cache: subroutine
	; frame 0
	lda #0
        tax
        lda #$20
.loop
        sta starfield_msg_cache,x
        inx
        cpx #$20
        bne .loop
        rts

starfield_dashboard_rows_table: 
	.word $22c0, $22e0, $2300, $2320, $2340, $2360
        
starfield_msgscroll_setup_clear_dash_space: subroutine
	; frame 1-6
	ldx state_v7
        dex
        dex ; off by 1? this works!
        txa
        asl
        tax
        lda starfield_dashboard_rows_table,x
        sta state_v0
        sta state_v2
        stx state_v4
        inx
        ldy starfield_dashboard_rows_table,x
        ;iny
        sty state_v1
        sta state_v3
	rts
        
starfield_msgscroll_setup_populate_message: subroutine
	lda #$61
        sta scroll_y
        rts
 	; scroll from $61 to $ef? maybe $f8?
        
starfield_msgscroll_setup_next_state: subroutine
	jmp starfield_spr2bg_init
        
        
starfield_spr_set_next: subroutine
	; decides if a star exists and its y pos, spr, att
        ; x = oam offset
        jsr get_next_random
        lsr
        and STARFIELD_MASK
        cmp #$16
        bcc .is_star
.no_star
        lda #$ff
        sta oam_ram_y,x
        rts
.is_star
	asl
        asl
        asl
        clc
        adc #$08
        sta oam_ram_y,x
        lda starfield_sprite
        sta oam_ram_spr,x
        ; set spr pal based on x position
	txa
        lsr
        lsr
        lsr
        and #1
        clc
        ; $20 = behind bg tiles
        ; $02 = use sprite palettes 2 and 3
        adc #$22
        sta oam_ram_att,x
        rts
        
        

starfield_spr2bg_init: subroutine
	lda #1
        sta starfield_state
	rts
        

        
starfield_spr2bg_update: subroutine
	; set bg close to 0
        ; start populating columns
        ; free sprites as they leave to the right
	rts
        
        
        
        
                
starfield_tile_left_border: subroutine
        ; make sure sprite0 has something to collide with
        PPU_SETADDR $2000
        ; update column
        lda #CTRL_INC_32
        sta PPU_CTRL
        lda #$1d ; col1 block
        ldx #$20
.col_loop
        sta PPU_DATA
        dex
        bne .col_loop
        ; put PPU address counter back to normal
        lda #CTRL_INC_1
        sta PPU_CTRL
        rts
        
        
        
        
starfield_twinkle_reset: subroutine
	lda STARFIELD_COL0_START
        sta starfield_col0
        lda STARFIELD_COL1_START
        sta starfield_col1
	rts
        
        
starfield_twinkle_colors: subroutine
        lda starfield_col0
        jsr palette_next_rainbow_color
        sta starfield_col0
        lda starfield_col1
        jsr palette_next_rainbow_color
        sta starfield_col1
	rts
        
starfield_twinkle_bg: subroutine
	lda starfield_col0
        sta pal_bg_0_1
        clc
        adc #$21
        sta pal_bg_0_2
        adc #$0d
        sta pal_bg_0_3
        lda starfield_col1
        sta pal_bg_1_1
        clc
        adc #$21
        sta pal_bg_1_2
        adc #$0d
        sta pal_bg_1_3
	rts
        
starfield_twinkle_spr: subroutine
        lda starfield_col0
        sta pal_spr_2_1
        clc
        adc #$21
        sta pal_spr_2_2
        adc #$0d
        sta pal_spr_2_3
        lda starfield_col1
        sta pal_spr_3_1
        clc
        adc #$21
        sta pal_spr_3_2
        adc #$0d
        sta pal_spr_3_3
	rts
