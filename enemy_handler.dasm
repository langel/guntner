;;;; Constants

ENEMY_HIT_PALETTE_FRAMES	= #$04

enemy_ram_type = $0300
enemy_ram_hp   = $0301
enemy_ram_x    = $0302
enemy_ram_y    = $0303
enemy_ram_pc   = $0304
enemy_ram_ac   = $0305
enemy_ram_hc   = $0306
enemy_ram_ex   = $0307

oam_ram_x      = $0203
oam_ram_y      = $0200
oam_ram_spr    = $0201
oam_ram_att    = $0202

oam_enemy_sprites = $0220



;;;; enemy types
;	0 = [nothing]
;	1 = starglasses	2x2
;	2 = skully	2x2
;	3 = maggs	2x1
;	4 = birb	1x1
;	5 = bullet0	1x1


	;include "enemy_birb.dasm"
        

enemy_handler_init: subroutine
	; set all sprites below the fold
        lda #$ff
	rts
        

sprite_4_set_sprite: subroutine
	; a = top left tile id
        ; y = oam ram offset
	sta oam_ram_spr,y
        clc
        adc #$01
	sta oam_ram_spr+4,y
        adc #$0f
	sta oam_ram_spr+8,y
	adc #$01
	sta oam_ram_spr+12,y
        rts
        
sprite_4_set_sprite_flip: subroutine
	; a = top left tile id
        ; y = oam ram offset
	sta oam_ram_spr+8,y
        clc
        adc #$01
	sta oam_ram_spr+12,y
        adc #$0f
	sta oam_ram_spr+0,y
	adc #$01
	sta oam_ram_spr+4,y
        rts
        
sprite_4_set_sprite_mirror: subroutine
	; a = top left tile id
        ; y = oam ram offset
	sta oam_ram_spr+4,y
        clc
        adc #$01
	sta oam_ram_spr+0,y
        adc #$0f
	sta oam_ram_spr+12,y
	adc #$01
	sta oam_ram_spr+8,y
        rts
	
        
sprite_4_set_x: subroutine
	; a = x pos
        ; y = oam ram offset
	sta oam_ram_x,y
	sta oam_ram_x+8,y
	clc
	adc #$08
	sta oam_ram_x+4,y
	sta oam_ram_x+12,y
	rts
        
sprite_4_set_y: subroutine
	; a = y pos
        ; y = oam ram offset
	sta oam_ram_y,y
	sta oam_ram_y+4,y
	clc
	adc #$08
	sta oam_ram_y+8,y
	sta oam_ram_y+12,y
	rts
        
sprite_4_dead_cleanup: subroutine
	lda #$04 ; move first sprite over 4 pixels
        clc
	adc oam_ram_x,y
        sta oam_ram_x,y
	lda #$04 ; move first sprite down 3 pixels
        clc
        adc oam_ram_y,y
        sta oam_ram_y,y
        ; move other sprites off screen
	lda #$ff
        sta oam_ram_y+4,y
        sta oam_ram_y+8,y
        sta oam_ram_y+12,y
        rts
        

enemy_fix_y_visible: subroutine
	; a = y position to check
	; returns new y position in a
        cmp #255-8
        bcc .not_wrapped_from_top
        sta temp00
        lda #255
        sec
        sbc sprite_0_y
        sta temp01
        lda temp00
        sec
        sbc temp01
        rts
.not_wrapped_from_top
	cmp sprite_0_y
        bcc .not_wrapped_from_bottom
        sec
        sbc sprite_0_y
.not_wrapped_from_bottom
	rts
	
        
clear_all_enemies: subroutine
	; XXX clears entire page and then some
	ldx #$00
        txa
.enemy_loop
	sta enemy_ram_type,x
        inx
        bne .enemy_loop
        ; XXX only clears enemy sprites
        lda #$ff
	ldx #$20
.sprite_loop
	sta $0200,x
        inx
        bne .sprite_loop
        rts
        
        
enemy_death: subroutine
        ; clear OAM data
        ldy enemy_oam_offset
        lda #$ff
        sta oam_ram_x,y
        sta oam_ram_y,y
        sta oam_ram_spr,y
        sta oam_ram_att,y
        ; clear enemy data
        lda #$00
	ldx enemy_ram_offset
        sta enemy_ram_type,x
        sta enemy_ram_x,x
        sta enemy_ram_y,x
        sta enemy_ram_hp,x
        sta enemy_ram_pc,x
        sta enemy_ram_ac,x
        sta enemy_ram_hc,x
        ; enemy_ram_ex is allowed to carry over
        ; entities using _ex should set it on spawn
        rts
        
        
enemy_slot_offset_to_oam_offset:
	; slots leftshift 3 times to get enemy_ram_offset
        ; 1 sprite slots : start at $300
        byte $20,$24,$28,$2c,$30,$34,$38,$3c
        byte $40,$44,$48,$4c,$50,$54,$58,$5c
        ; 2 sprite slots : start at $380
        byte $60,$68,$70,$78
        ; 4 sprite slots : start at $3a0
        byte $80,$90,$a0,$b0,$c0,$d0,$e0,$f0
        ; null terminater
        byte $00
        
        
enemies_update_all: subroutine
	; set max darts launched per frame
        lda #$04
        sta dart_frame_max
	; if player is dead despawn
	lda player_health
        beq player_dead_enemies_despawn
	; cycle through all the slots
	ldx #$00
        stx enemy_slot_id
        stx enemy_ram_offset
        ldy enemy_slot_offset_to_oam_offset,x
        sty enemy_oam_offset
.handler_loop
        ldx enemy_ram_offset
	; get enemy type
        lda enemy_ram_type,x
        ; not defined go next slot
        beq .handler_next
        tax
        lda enemy_update_table_lo,x
        sta temp00
        lda enemy_update_table_hi,x
        sta temp01
        ; setup collision detection enemy origin pos
	ldx enemy_ram_offset
        ldy enemy_oam_offset
        lda oam_ram_x,y
        sta collision_0_x
        lda oam_ram_y,y
        sta collision_0_y
        jmp (temp00)
update_enemies_handler_next:
.handler_next
        ; go to next enemy slot
        inc enemy_slot_id
        lda enemy_slot_id
        asl
        asl
        asl
        sta enemy_ram_offset
        ldx enemy_slot_id
        ldy enemy_slot_offset_to_oam_offset,x
        sty enemy_oam_offset
        bne .handler_loop
        rts
        
        
        
             
player_dead_enemies_despawn: subroutine
	; enemies slide off left side of screen
        ; after player dies
        lda #$05
        clc
        adc player_death_flag
        bcc .carry_clear
        lda #$ff
.carry_clear
        sta player_death_flag
        lsr
        lsr
        lsr
        lsr
        sta temp00
        ldx #$20
.loop
        lda oam_ram_x,x
        beq .do_nothing
        sec
        sbc temp00
        bmi .despawn
        sta oam_ram_x,x
        jmp .do_nothing
.despawn
	lda #$00
        sta oam_ram_x,x
	lda #$ff
        sta oam_ram_y,x
.do_nothing
        inx
        inx
        inx
        inx
        bne .loop
        rts
        
        

enemy_spawn_random_y_pos: subroutine
	jsr get_next_random
        lsr
        clc
        adc #$10
	rts
        
        
        
crossbones_cycle: subroutine
        inc enemy_ram_hp,x
        lda enemy_ram_hp,x
        lsr
        lsr
        lsr
        sta enemy_ram_y,x
        lda oam_ram_y,y
        sec
        sbc enemy_ram_y,x
        bmi .crossbones_death
        sta oam_ram_y,y
        lda #$0b
        sta oam_ram_spr,y
        lda #$03
        sta oam_ram_att,y
        jmp .crossbones_done
.crossbones_death
        jsr enemy_death
.crossbones_done
	jmp update_enemies_handler_next
        
        
  

; XXX this seems to be included below    
enemy_give_points: subroutine
        ; a = enemy type
        stx temp00
        sty temp01
        asl
        asl
        clc
        adc #$03
        tay ; enemy points counter
        ldx #$03 ; score bytes counter
        clc
.score_loop
        lda ENEMY_PLAYER_POINTS_TABLE,y
        adc score_000000xx,x
        sta score_000000xx,x
        dey
	dex
	bne .score_loop
        ldx temp00
        ldy temp01
        rts

        
        
enemy_handle_damage_and_death: subroutine
	; x = enemy ram offset
        ; y = oam ram offset
	lda #$00
        sta enemy_dmg_accumulator
; handle bullet collisions
        jsr player_bullet_collision_handler
	jsr player_collision_detect
        beq .no_collision
; handle player collision
	; player damage
        ldy enemy_ram_type,x
        lda ENEMY_PLAYER_COLLISION_TABLE,y
        ldy enemy_ram_ex,x
        sta player_damage
        jsr player_take_damage
        jsr sfx_player_damage
	lda enemy_dmg_accumulator
        clc
        adc #$02
        sta enemy_dmg_accumulator
.no_collision
; handle bomb explosion
        lda bomb_counter
        beq .no_bomb_damage
        lda wtf
        and #1
        beq .no_bomb_damage
        inc enemy_dmg_accumulator
.no_bomb_damage
	; fix y register
	ldy enemy_oam_offset
; handle damage accumulated
        lda enemy_dmg_accumulator
        bne .hit
        rts
.hit
	lda enemy_ram_hp,x
        sec
        sbc enemy_dmg_accumulator
        sta enemy_ram_hp,x
        bcc .dead
	
        lda #ENEMY_HIT_PALETTE_FRAMES
	sta enemy_ram_hc,x
	jsr sfx_enemy_damage
        rts
.dead
	; XXX should only do this on smaller enemies
	inc phase_kill_count
        jsr sfx_enemy_death
        ; boss death check
        lda boss_dmg_handle_true
        beq .not_boss_death
        lda #$00
.boss_dead_kill_all
	tax
        lda #$01
        sta enemy_ram_type,x
        txa
	cmp #$a0
        bcc .not_4_sprites
        sta temp00
        lsr
        lsr
        lsr
        tax
        ldy enemy_slot_offset_to_oam_offset,x
        ldx temp00
        jsr sprite_4_dead_cleanup
        lda temp00
.not_4_sprites
        clc
        adc #$08
        cmp #$e0
        bne .boss_dead_kill_all
        lda #$00
        sta boss_dmg_handle_true
.not_boss_death
	; handle point bonus
	lda enemy_ram_type,x
        asl
        asl
        clc
        adc #$03
        tay ; enemy points counter
        ldx #$03 ; score bytes counter
        clc
.score_loop
        lda ENEMY_PLAYER_POINTS_TABLE,y
        adc score_000000xx,x
        sta score_000000xx,x
        dey
	dex
	bne .score_loop
        ldx enemy_ram_offset
        ldy enemy_oam_offset
; 4 sprite cleanup
	cpx #$80
        bcc .not_4_sprite
        jsr sprite_4_dead_cleanup
.not_4_sprite
; starglasses 
        lda enemy_ram_type,x
        cmp #$04
        bne .not_starglasses
        lda bomb_counter
        bne .not_starglasses
        ; spawn powerup
        pla 
        pla
        jmp powerup_from_starglasses
.not_starglasses
        ; change it into crossbones!
        lda #$01
        sta enemy_ram_type,x
        sta enemy_ram_hp,x
        ; return to enemy handler not cycle
        pla
        pla
        jmp crossbones_cycle
        
        
        
enemy_set_palette: subroutine
	; checks/handles hit palette counter
        ; a = enemy normal palette
	; x = enemy ram offset
        ; y = oam ram offset
        ; leaves correct palette id in a
        ; can be applied to extra sprites of larger enemy
        clc ; set carry for branching on return
        sta temp00
        lda enemy_ram_hc,x
        beq .use_enemy_palette
.use_hit_palette
	dec enemy_ram_hc,x
        lda temp00
        and #%11111100
        sta oam_ram_att,y
        rts
.use_enemy_palette
	lda temp00
        sta oam_ram_att,y
        rts
        
        
        


; 16 1 sprite enemies
; 4  2 sprite enemies
; 8  4 sprite enemies
; 28 total on screen enemies / entities
; 1 sprite can occupy all slots
; 2 sprite can occupy 12 slots
; 4 sprite restricted to their 8 slots

slot_offset_to_oam_offset_table:
	; 16 slots using 1 sprite
	.byte $20, $24, $28, $2c, $30, $34, $38, $3c
        .byte $40, $44, $48, $4c, $50, $54, $58, $5c
        ; 4 slots using 2 sprites
        .byte $60, $68, $70, $78
        ; 8 slots using 4 sprites
        .byte $80, $90, $a0, $b0, $c0, $d0, $e0, $f0

get_oam_offset_from_slot_offset: subroutine
	; x = slot offset
        ; returns oam offset in y
        stx temp00
        txa
        lsr
        lsr
        lsr
        tax
        ldy slot_offset_to_oam_offset_table,x
        ldx temp00
        rts
        
get_enemy_slot_cache_next:
        ; XXX should be refactored to use subroutines below
        ;     also do we even need this?
        ; XXX should either remove this or use it more!
;get_enemy_slot_1_sprite: subroutine
	; returns enemy_ram offset
        lda #$00
.slot_1_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_1_found
        lda #$08
        clc
        adc temp00
        cmp #$80
        bne .slot_1_loop
.no_available_slot_1
        ldx #$ff 
.slot_1_found
	stx enemy_slot_1_next
        
;get_enemy_slot_2_sprite: subroutine
	; returns enemy_ram offset
        lda #$80
.slot_2_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_2_found
        lda #$08
        clc
        adc temp00
        cmp #$a0
        bne .slot_2_loop
.no_available_slot_2
        ldx #$ff 
.slot_2_found
	stx enemy_slot_2_next
        
;get_enemy_slot_4_sprite: subroutine
	; returns enemy_ram offset
        lda #$a0
.slot_4_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_4_found
        lda #$08
        clc
        adc temp00
        cmp #$e0
        bne .slot_4_loop
.no_available_slot_4
        ldx #$ff 
.slot_4_found
	stx enemy_slot_4_next
	rts
        
        
get_enemy_slot_1_count: subroutine
	; returns number of enemies of slot_1 type in a
        lda #$00
        sta temp01 ; occupied count
.loop
        sta temp00 ; slot offset
        lda temp00
        tax
        lda $0300,x
        beq .slot_empty
        inc temp01
.slot_empty
	lda #$08
        clc
        adc temp00
        cmp #$80
        bne .loop
        lda temp01
        rts
        

get_enemy_slot_next: subroutine
	; returns enemy_ram_offset in x
        lda #$d8
.slot_loop
	tax
        stx temp00
        lda $0300,x
        beq .slot_found
        lda temp00
        sec
        sbc #$08
        bcs .slot_loop
.no_slot
	ldx #$ff
.slot_found
	rts
        

get_enemy_slot_1_sprite: subroutine
	; returns enemy_ram offset
        lda #$00
.slot_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_found
        lda #$08
        clc
        adc temp00
        cmp #$80
        bne .slot_loop
.no_available_slot
        ldx #$ff 
.slot_found
	txa
	rts
        
get_enemy_slot_2_sprite: subroutine
	; returns enemy_ram offset
        lda #$80
.slot_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_found
        lda #$08
        clc
        adc temp00
        cmp #$a0
        bne .slot_loop
.no_available_slot
        ldx #$ff 
.slot_found
	txa
	rts
        
get_enemy_slot_4_sprite: subroutine
	; returns enemy_ram offset
        lda #$a0
.slot_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_found
        lda #$08
        clc
        adc temp00
        cmp #$e0
        bne .slot_loop
.no_available_slot
        ldx #$ff 
.slot_found
	txa
	rts