;;;; Constants

ENEMY_HIT_PALETTE_FRAMES	EQM $04

phase_spawn_table	= $0160

oam_ram_x      = $0203
oam_ram_y      = $0200
oam_ram_spr    = $0201
oam_ram_att    = $0202

oam_enemy_sprites = $0220


enemy_ram_type = $0300
enemy_ram_hp   = $0301
enemy_ram_x    = $0302
enemy_ram_y    = $0303
enemy_ram_pc   = $0304
enemy_ram_ac   = $0305
enemy_ram_hc   = $0306
enemy_ram_ex   = $0307

;;;; enemy types
;	0 = [nothing]
;	1 = starglasses	2x2
;	2 = skully	2x2
;	3 = maggs	2x1
;	4 = birb	1x1
;	5 = bullet0	1x1


	;include "enemy_birb.dasm"
        


enemy_spawn_delegator: subroutine
	; a = enemy type id
        ; x = enemy ram slot position
        sta enemy_ram_type,x 
        tay
        sty temp00 ; enemy type
    	; do hit point maths
        ; hp * (game difficulty + 1) 
        lda enemy_hitpoints_table,y
        sta temp01 ; enemy hp
        lda #$01
        clc
        adc game_difficulty
        tay
        lda #$00
.enemy_hp_loop
	adc temp01
        dey
        bne .enemy_hp_loop
        ; save hp result
        sta enemy_ram_hp,x 
        ; jump to enemy type spawner
        ldy temp00 ; enemy type
        lda enemy_spawn_table_lo,y
        sta temp02
        lda enemy_spawn_table_hi,y
        sta temp03
        jmp (temp02)
        

sprite_4_set_sprite: subroutine
	; a = top left tile id
        ; y = oam ram offset
	sta oam_ram_spr,y
        clc
        adc #$01
	sta oam_ram_spr+4,y
        adc #$0f
	sta oam_ram_spr+8,y
	adc #$01
	sta oam_ram_spr+12,y
        rts
        
sprite_4_set_sprite_flip: subroutine
	; a = top left tile id
        ; y = oam ram offset
	sta oam_ram_spr+8,y
        clc
        adc #$01
	sta oam_ram_spr+12,y
        adc #$0f
	sta oam_ram_spr+0,y
	adc #$01
	sta oam_ram_spr+4,y
        rts
        
sprite_4_set_sprite_mirror: subroutine
	; a = top left tile id
        ; y = oam ram offset
	sta oam_ram_spr+4,y
        clc
        adc #$01
	sta oam_ram_spr+0,y
        adc #$0f
	sta oam_ram_spr+12,y
	adc #$01
	sta oam_ram_spr+8,y
        rts
	
        
sprite_4_set_x: subroutine
	; a = x pos
        ; y = oam ram offset
	sta oam_ram_x,y
	sta oam_ram_x+8,y
	clc
	adc #$08
	sta oam_ram_x+4,y
	sta oam_ram_x+12,y
	rts
        
sprite_4_set_y: subroutine
	; a = y pos
        ; y = oam ram offset
	sta oam_ram_y,y
	sta oam_ram_y+4,y
	clc
	adc #$08
	sta oam_ram_y+8,y
	sta oam_ram_y+12,y
	rts
        
sprite_4_dead_cleanup: subroutine
	lda #$04 ; move first sprite over 4 pixels
        clc
	adc oam_ram_x,y
        sta oam_ram_x,y
	lda #$04 ; move first sprite down 3 pixels
        clc
        adc oam_ram_y,y
        sta oam_ram_y,y
        ; move other sprites off screen
	lda #$ff
        sta oam_ram_y+4,y
        sta oam_ram_y+8,y
        sta oam_ram_y+12,y
        rts
        

enemy_fix_y_visible: subroutine
	; a = y position to check
	; returns new y position in a
        cmp #255-8
        bcc .not_wrapped_from_top
        sta temp00
        lda #255
        sec
        sbc sprite_0_y
        sta temp01
        lda temp00
        sec
        sbc temp01
        rts
.not_wrapped_from_top
	cmp sprite_0_y
        bcc .not_wrapped_from_bottom
        sec
        sbc sprite_0_y
.not_wrapped_from_bottom
	rts
	
        
clear_all_enemies: subroutine
	; clears all enemy ram
	ldx #$f0
        lda #$00
.enemy_loop
	dex
	sta enemy_ram_type,x
        bne .enemy_loop
        ; clears all enemy sprites
        lda #$ff
	ldx #$20
.sprite_loop
	sta $0200,x
        inx
        bne .sprite_loop
        rts
        
        
enemy_death: subroutine
        ; clear OAM data
        ldy enemy_oam_offset
        lda #$ff
        sta oam_ram_x,y
        sta oam_ram_y,y
        sta oam_ram_spr,y
        sta oam_ram_att,y
        ; clear enemy data
        lda #$00
	ldx enemy_ram_offset
        sta enemy_ram_type,x
        sta enemy_ram_x,x
        sta enemy_ram_y,x
        sta enemy_ram_hp,x
        sta enemy_ram_pc,x
        sta enemy_ram_ac,x
        sta enemy_ram_hc,x
        ; enemy_ram_ex is allowed to carry over
        ; entities using _ex should set it on spawn
        rts
        
        
enemy_slot_offset_to_oam_offset:
	; slots leftshift 3 times to get enemy_ram_offset
        ; 1 sprite slots : start at $300
	; 16 slots using 1 sprite
        byte $20,$24,$28,$2c,$30,$34,$38,$3c
        byte $40,$44,$48,$4c,$50,$54,$58,$5c
        ; 2 sprite slots : start at $380
        ; 4 slots using 2 sprites
        byte $60,$68,$70,$78
        ; 4 sprite slots : start at $3a0
        ; 8 slots using 4 sprites
        byte $80,$90,$a0,$b0,$c0,$d0,$e0,$f0
        ; null terminater
        byte $00
        
        
        
enemies_update_all: subroutine
	lda boss_death_happening
        bne .done
	; set max darts launched per frame
        lda #$03
        sta dart_frame_max
	; if player is dead despawn
	lda player_health
        bne .player_alive
        beq player_dead_enemies_despawn
.player_alive
	; cycle through all the slots
	ldx #$00
        stx enemy_slot_id
        stx enemy_ram_offset
        ldy enemy_slot_offset_to_oam_offset,x
        sty enemy_oam_offset
.handler_loop
        ldx enemy_ram_offset
	; get enemy type
        lda enemy_ram_type,x
        ; not defined go next slot
        beq .handler_next
        tax
        lda enemy_update_table_lo,x
        sta temp00
        lda enemy_update_table_hi,x
        sta temp01
        ; setup collision detection enemy origin pos
	ldx enemy_ram_offset
        ldy enemy_oam_offset
        lda oam_ram_x,y
        sta collision_0_x
        lda oam_ram_y,y
        sta collision_0_y
        jmp (temp00)
update_enemies_handler_next:
.handler_next
        ; go to next enemy slot
        inc enemy_slot_id
        lda enemy_slot_id
        asl
        asl
        asl
        sta enemy_ram_offset
        ldx enemy_slot_id
        ldy enemy_slot_offset_to_oam_offset,x
        sty enemy_oam_offset
        bne .handler_loop
.done
        rts
        
        
        
             
player_dead_enemies_despawn: subroutine
	; enemies slide off left side of screen
        ; after player dies
        ldx #$df
.loop
        lda oam_enemy_sprites,x
        beq .next
        sec
        sbc player_death_flag
        sta oam_enemy_sprites,x
        cmp #$f0
        bcc .next
.despawn
	lda #$00
        sta oam_enemy_sprites,x
	lda #$ff
        sta oam_enemy_sprites-3,x
.next
	dex
        dex
        dex
        dex
        cpx #$ff
        bne .loop
        lda wtf
        and #$01
        bne .dont_increase_velocity
        inc player_death_flag
.dont_increase_velocity
        rts
        
        

enemy_spawn_random_y_pos: subroutine
	jsr get_next_random
        lsr
        clc
        adc #$10
	rts
        
        
        
crossbones_cycle: subroutine
        inc enemy_ram_hp,x
        lda enemy_ram_hp,x
        lsr
        lsr
        lsr
        sta enemy_ram_y,x
        lda oam_ram_y,y
        sec
        sbc enemy_ram_y,x
        cmp sprite_0_y
        bcs .crossbones_death
        sta oam_ram_y,y
        lda #$0b
        sta oam_ram_spr,y
        lda #$03
        sta oam_ram_att,y
        jmp .crossbones_done
.crossbones_death
        jsr enemy_death
.crossbones_done
	jmp update_enemies_handler_next
        

      
    
game_difficulty_damage_table:
	byte #58, #77, #109, #191  
        
enemy_handle_damage_and_death: subroutine
	; x = enemy ram offset
        ; y = oam ram offset
	lda #$00
        sta enemy_dmg_accumulator
; handle bullet collisions
        jsr player_bullet_collision_handler
	jsr player_collision_detect
        beq .no_collision
; handle player collision
	; player damage
	; XXX put damage amount in player_damage
        ; XXX this might be set in 3 different places rn
        ldy game_difficulty
        lda game_difficulty_damage_table,y
        ;ldy enemy_ram_type,x
        ;lda enemy_player_collision_table,y
        ;ldy enemy_ram_ex,x
        sta player_damage
        jsr player_take_damage
        jsr sfx_player_damage
	lda enemy_dmg_accumulator
        clc
        adc #$02
        sta enemy_dmg_accumulator
.no_collision
; handle bomb explosion
        lda bomb_counter
        beq .no_bomb_damage
        lda wtf
        and #1
        beq .no_bomb_damage
        inc enemy_dmg_accumulator
.no_bomb_damage
	; fix y register
	ldy enemy_oam_offset
; handle damage accumulated
        lda enemy_dmg_accumulator
        bne .hit
        rts
.hit
	lda enemy_ram_hp,x
        sec
        sbc enemy_dmg_accumulator
        sta enemy_ram_hp,x
        bcc .dead
	
        lda #ENEMY_HIT_PALETTE_FRAMES
	sta enemy_ram_hc,x
	jsr sfx_enemy_damage
        rts
.dead
        ; boss death check
        lda boss_dmg_handle_true
        beq .not_boss_death
        inc boss_death_happening
        inc boss_heart_stars
        rts
.not_boss_death
	; handle point bonus
	lda enemy_ram_type,x
.enemy_type_already_set
        asl
        asl
        clc
        adc #$03
        tay ; enemy points counter
        ldx #$03 ; score bytes counter
        clc
.score_loop
        lda enemy_player_points_table,y
        adc score_000000xx,x
        sta score_000000xx,x
        dey
	dex
	bpl .score_loop
        ldx enemy_ram_offset
        ldy enemy_oam_offset
; 4 sprite cleanup
	cpx #$80
        bcc .dont_cleanup_4_sprite
        jsr sprite_4_dead_cleanup
.dont_cleanup_4_sprite
; starglasses 
        lda enemy_ram_type,x
        cmp #starglasses_id
        bne .not_starglasses
        ; spawn powerup
        pla 
        pla
        jmp powerup_from_starglasses
.not_starglasses
	; track deaths of phase spawns
        ldy enemy_slot_id
        lda phase_spawn_table,y
        beq .not_phase_spawn
        lda #$00
        sta phase_spawn_table,y
	dec phase_kill_counter
.not_phase_spawn
        jsr sfx_enemy_death
        ; change it into crossbones!
        lda #crossbones_id
        sta enemy_ram_type,x
        sta enemy_ram_hp,x
        ldy enemy_oam_offset
        ; return to enemy handler not cycle
        pla
        pla
        jmp crossbones_cycle
        
        
        
enemy_set_palette: subroutine
	; checks/handles hit palette counter
        ; a = enemy normal palette
	; x = enemy ram offset
        ; y = oam ram offset
        ; leaves correct palette id in a
        ; can be applied to extra sprites of larger enemy
        clc ; set carry for branching on return
        sta temp00
        lda enemy_ram_hc,x
        beq .use_enemy_palette
.use_hit_palette
	dec enemy_ram_hc,x
        lda temp00
        and #%11111100
        sta oam_ram_att,y
        rts
.use_enemy_palette
	lda temp00
        sta oam_ram_att,y
        rts
        
        
        


; 16 1 sprite enemies
; 4  2 sprite enemies
; 8  4 sprite enemies
; 28 total on screen enemies / entities
; 1 sprite can occupy all slots
; 2 sprite can occupy 12 slots
; 4 sprite restricted to their 8 slots


get_oam_offset_from_slot_offset: subroutine
	; x = slot offset
        ; returns oam offset in y
        stx temp00
        txa
        lsr
        lsr
        lsr
        tax
        ldy enemy_slot_offset_to_oam_offset,x
        ldx temp00
        rts
        
        
        

get_enemy_slot_next: subroutine
	; returns enemy_ram_offset in x
        ; works from the top down
        lda #$d8
.slot_loop
	tax
        stx temp00
        lda $0300,x
        beq .slot_found
        lda temp00
        sec
        sbc #$08
        bcs .slot_loop
.no_slot
	ldx #$ff
.slot_found
	rts
        
        
enemy_slot_from_type: subroutine
	; y = enemy type id
        ; returns slot offset in a
        ldx enemy_size_table,y
        cpx #1
        bne .not_size_1
	jsr get_enemy_slot_1_sprite
        rts
.not_size_1
	cpx #2
        bne .not_size_2
	jsr get_enemy_slot_2_sprite
        rts
.not_size_2
	jsr get_enemy_slot_4_sprite
	rts
        

get_enemy_slot_1_sprite: subroutine
	; returns enemy_ram offset
        lda #$00
.slot_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_found
        lda #$08
        clc
        adc temp00
        cmp #$80
        bne .slot_loop
.no_available_slot
        ldx #$ff 
.slot_found
	txa
	rts
        
get_enemy_slot_2_sprite: subroutine
	; returns enemy_ram offset
        lda #$80
.slot_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_found
        lda #$08
        clc
        adc temp00
        cmp #$a0
        bne .slot_loop
.no_available_slot
        ldx #$ff 
.slot_found
	txa
	rts
        
get_enemy_slot_4_sprite: subroutine
	; returns enemy_ram offset
        lda #$a0
.slot_loop
	tax
        stx temp00
        lda $0300,x
        cmp #$00
        beq .slot_found
        lda #$08
        clc
        adc temp00
        cmp #$e0
        bne .slot_loop
.no_available_slot
        ldx #$ff 
.slot_found
	txa
	rts