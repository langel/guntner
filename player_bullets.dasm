
;;;;;; Constants

bullet_cooldown_length	= $14


bullet0		= $020c
bullet1		= $0210
bullet2		= $0214
bullet3		= $0218
bullet4		= $021c

player_bullet_sprite	= #$79

controller_input	= #$ff
player_power		= #$ff

        
player_demo_init: subroutine
; set player position
	lda #$00
        sta player_death_flag
        sta you_dead_counter
	lda #$d0
        sta player_x
        sta player_demo_x
	lda #$70
        sta player_y
        sta player_demo_y
        lda #$ff
        sta player_health
  ; SCROLL SPEED
  	lda #$07
        sta scroll_speed
        asl
        asl
        asl
        sta scroll_speed_m
        
        ldx #$8f ; set tiles
        stx $205
        dex 
        stx $209
        rts
        
        
player_add_points: subroutine
; point amount in Accumulator
	clc
        adc score_00
        sta score_00
        sec 
        sbc #$64
        bcc .done_00
        inc score_00__
        sta score_00
.done_00
	rts
        
        
player_update_colors: subroutine
	PPU_SETADDR $3f0d
	lda player_color0
        sta PPU_DATA
	lda player_color1
        sta PPU_DATA
	lda player_color2
        sta PPU_DATA
	PPU_SETADDR $3f11
	lda player_color2
        sta PPU_DATA
	lda player_color1
        sta PPU_DATA
	lda player_color0
        sta PPU_DATA
	rts
        
        
; set palette colors
; set PPU address to palette start
	PPU_SETADDR $3f00
        ldy #0
.loop:
	lda Palette00,y	; lookup byte in ROM
	sta PPU_DATA	; store byte to PPU data
        iny		; Y = Y + 1
        cpy #32		; is Y equal to 32?
	bne .loop	; not yet, loop
        rts		; return to caller
        
        
        
player_take_damage: subroutine
; damage amount in player_damage
	lda player_health
        sec
        sbc player_damage
        bcc .player_dead
        sta player_health
        rts
.player_dead
	; player_health 00 means DEATH
	lda #$00
        sta player_health
        ; change sprite
	ldx #$0a
        stx $205
        stx $209
        rts
        
        
player_collision_detect: subroutine
	lda player_x
        sta collision_1_x
        lda player_y
        clc
        adc #$02
        sta collision_1_y
        lda #$10
        sta collision_1_w
        lda #$06
        sta collision_1_h
        jsr detect_collision
        cmp #$00
        beq .done
        ; XXX this number is sus
        ; player sprites don't always change at death
        lda #$04
        sta player_damage
        jsr player_take_damage
.done
        rts
        
        
set_player_sprite: subroutine
	lda player_y
        sta $204
        sta $208
        lda player_x
        sta $207
        clc
        adc #$08
        sta $20b
        
        lda #$40
; attributes
        sta $206
        sta $20a
     	; work towards demo target
        lda player_x
        cmp player_demo_x
        beq set_player_demo_x
        bcs set_player_demo_x_dec
        inc player_x
        jmp set_player_demo_x_done
set_player_demo_x_dec:
	dec player_x
set_player_demo_x_done:
        lda player_y
        cmp player_demo_y
        beq set_player_demo_y
        bcs set_player_demo_y_dec
        inc player_y
        jmp set_player_demo_y_done
set_player_demo_y_dec:
	dec player_y
set_player_demo_y_done:
	rts
        
set_player_demo_x:
	lda rng0
        jsr NextRandom
        sta rng0
        lsr
        clc
        adc #$70
        sta player_demo_x
        jmp set_player_demo_x_done
set_player_demo_y:
	lda rng0
        jsr NextRandom
        sta rng0
        lsr
        clc
        adc #$10
        sta player_demo_y
	jmp set_player_demo_y_done
        
        

;;; player bullet struct
; byte 0 : x pos
; byte 1 : y pos

; bullets are sprites #$03 - #$07 
;;; bullet directions, sprite base address
; 03   9 o'clock -7,  0, $020c
; 04  10 o'clock -6, -3, $0210
; 05   8 o'clock -6. +3, $0214
; 06  11 o'clock -3, -6, $0218
; 07   7 o'clock -3, +6, $021c


player_bullets_init:
	lda #bullet_cooldown_length
        sta bullet_cooldown
        rts
        
        
player_bullet_collision_handler: subroutine
	stx player_bullet_collision_temp_x
	clc
        lda collision_0_x
        adc collision_0_w
        bcc .in_bounds; make sure x+w is not less than x
        lda #$00
        rts
.in_bounds        
        ; bullet dimensiosn don't change
        lda #$04
        sta collision_1_w
        sta collision_1_h
        
        ; accumulate number of bullets colliding in x register
        ldx #$00
        
        lda bullet0 + 3
        cmp #$00
        beq .bullet0_skip
        sta collision_1_x
        lda bullet0 + 0
        sta collision_1_y
        jsr detect_collision
        cmp #$00
        beq .bullet0_skip
        inx
        jsr bullet0_despawn
.bullet0_skip        

        lda bullet1 + 3
        cmp #$00
        beq .bullet1_skip
        sta collision_1_x
        lda bullet1 + 0
        sta collision_1_y
        jsr detect_collision
        cmp #$00
        beq .bullet1_skip
        inx
        jsr bullet1_despawn
.bullet1_skip

        lda bullet2 + 3
        cmp #$00
        beq .bullet2_skip
        sta collision_1_x
        lda bullet2 + 0
        sta collision_1_y
        jsr detect_collision
        cmp #$00
        beq .bullet2_skip
        inx
        jsr bullet2_despawn
.bullet2_skip

        lda bullet3 + 3
        cmp #$00
        beq .bullet3_skip
        sta collision_1_x
        lda bullet3 + 0
        sta collision_1_y
        jsr detect_collision
        cmp #$00
        beq .bullet3_skip
        inx
        jsr bullet3_despawn
.bullet3_skip

        lda bullet4 + 3
        cmp #$00
        beq .bullet4_skip
        sta collision_1_x
        lda bullet4 + 0
        sta collision_1_y
        jsr detect_collision
        cmp #$00
        beq .bullet4_skip
        inx
        jsr bullet4_despawn
.bullet4_skip

	; send number of hits back to caller
	txa
        ldx player_bullet_collision_temp_x
	rts
        
        
bullet0_despawn: subroutine
	lda #$00
        sta bullet0
        sta bullet0 + 3
        lda #$80
        sta bullet0 + 1
        rts
bullet1_despawn: subroutine
	lda #$00
        sta bullet1
        sta bullet1 + 3
        lda #$80
        sta bullet1 + 1
        rts
bullet2_despawn: subroutine
	lda #$00
        sta bullet2
        sta bullet2 + 3
        lda #$80
        sta bullet2 + 1
        rts
bullet3_despawn: subroutine
	lda #$00
        sta bullet3
        sta bullet3 + 3
        lda #$80
        sta bullet3 + 1
        rts
bullet4_despawn: subroutine
	lda #$00
        sta bullet4
        sta bullet4 + 3
        lda #$80
        sta bullet4 + 1
        rts


; temp solution unti
player_bullets_despawn:
	jsr bullet0_despawn
	jsr bullet1_despawn
	jsr bullet2_despawn
	jsr bullet3_despawn
	jsr bullet4_despawn
        rts


player_bullets_update: subroutine

	; bullet 0
        ; check if fire is pressed
        ; XXX not implemented
        
        ; check if bullet is despawned
        lda bullet0 + 3
        cmp #$00
        bne .bullet0_spawned
        lda player_x
        sta bullet0 + 3
        lda player_y 
        clc
        adc #$04
        sta bullet0 + 0
        lda player_bullet_sprite
        sta bullet0 + 1
        lda #$03
        sta bullet0 + 2
.bullet0_spawned
        ; update x
        lda bullet0 + 3
        sec
        ;sbc #$07
        sbc #$04
        sta bullet0 + 3
        ; despawn if less than 0
        bcc .bullet0_despawn
        ; sprite
        lda #$79
        sta bullet0 + 1
        jmp .bullet0_done
.bullet0_despawn
	jsr bullet0_despawn
.bullet0_done

        
	; bullet 1
        ; check if fire is pressed
        ; check if player_power is > 1
        ; XXX not implemented
        
        ; check if bullet is despawned
        lda bullet1 + 3
        cmp #$00
        bne .bullet1_spawned
        lda player_x
        sta bullet1 + 3
        lda player_y 
        clc
        adc #$04
        sta bullet1 + 0
        lda player_bullet_sprite
        sta bullet1 + 1
        lda #$03
        sta bullet1 + 2
.bullet1_spawned
        ; update x
        lda bullet1 + 3
        sec
        ;sbc #$06
        sbc #$03
        sta bullet1 + 3
        ; despawn if less than 0
        bcc .bullet1_despawn
        sta bullet1 + 3
        ; update y
        lda bullet1 + 0
        sec
        sbc #$02
        ;sbc #$03
        sta bullet1 + 0
        ; despawn if less than 0
        bcc .bullet1_despawn
        ; sprite
        lda #$79
        sta bullet1 + 1
        jmp .bullet1_done
.bullet1_despawn
	lda #$00
        sta bullet1
        sta bullet1 + 3
        lda #$80
        sta bullet1 + 1
.bullet1_done

     
	; bullet 2
        ; check if fire is pressed
        ; check if player_power is > 2
        ; XXX not implemented
        
        ; check if bullet is despawned
        lda bullet2 + 3
        cmp #$00
        bne .bullet2_spawned
        lda player_x
        sta bullet2 + 3
        lda player_y 
        clc
        adc #$04
        sta bullet2 + 0
        lda player_bullet_sprite
        sta bullet2 + 1
        lda #$03
        sta bullet2 + 2
.bullet2_spawned
        ; update x
        lda bullet2 + 3
        sec
        ;sbc #$06
        sbc #$03
        sta bullet2 + 3
        ; despawn if less than 0
        bcc .bullet2_despawn
        sta bullet2 + 3
        ; update y
        lda bullet2 + 0
        clc
        ;adc #$03
        adc #$01
        sta bullet2 + 0
        cmp sprite_0_y	;y
        ; despawn if lower than hud pos
        bcs .bullet2_despawn
        ; sprite
        lda #$79
        sta bullet2 + 1
        jmp .bullet2_done
.bullet2_despawn
	lda #$00
        sta bullet2
        sta bullet2 + 3
        lda #$80
        sta bullet2 + 1
.bullet2_done

        
	; bullet 3
        ; check if fire is pressed
        ; check if player_power is > 3
        ; XXX not implemented
        
        ; check if bullet is despawned
        lda bullet3 + 3
        cmp #$00
        bne .bullet3_spawned
        lda player_x
        sta bullet3 + 3
        lda player_y 
        clc
        adc #$04
        sta bullet3 + 0
        lda player_bullet_sprite
        sta bullet3 + 1
        lda #$03
        sta bullet3 + 2
.bullet3_spawned
        ; update x
        lda bullet3 + 3
        sec
        ;sbc #$03
        sbc #$01
        sta bullet3 + 3
        ; despawn if less than 0
        bcc .bullet3_despawn
        sta bullet3 + 3
        ; update y
        lda bullet3 + 0
        sec
        ;sbc #$06
        sbc #$03
        sta bullet3 + 0
        ; despawn if less than 0
        bcc .bullet3_despawn
        ; sprite
        lda #$79
        sta bullet3 + 1
        jmp .bullet3_done
.bullet3_despawn
	lda #$00
        sta bullet3
        sta bullet3 + 3
        lda #$80
        sta bullet3 + 1
.bullet3_done


	; bullet 4
        ; check if fire is pressed
        ; check if player_power is > 4
        ; XXX not implemented
        
        ; check if bullet is despawned
        lda bullet4 + 3
        cmp #$00
        bne .bullet4_spawned
        lda player_x
        sta bullet4 + 3
        lda player_y 
        clc
        adc #$04
        sta bullet4 + 0
        lda player_bullet_sprite
        sta bullet4 + 1
        lda #$03
        sta bullet4 + 2
.bullet4_spawned
        ; update x
        lda bullet4 + 3
        sec
        ;sbc #$03
        sbc #$01
        sta bullet4 + 3
        ; despawn if less than 0
        bcc .bullet4_despawn
        sta bullet4 + 3
        ; update y
        lda bullet4 + 0
        clc
        ;adc #$06
        adc #$04
        sta bullet4 + 0
        cmp sprite_0_y	;y
        ; despawn if lower than hud pos
        bcs .bullet4_despawn
        ; sprite
        lda #$79
        sta bullet4 + 1
        jmp .bullet4_done
.bullet4_despawn
	lda #$00
        sta bullet4
        sta bullet4 + 3
        lda #$80
        sta bullet4 + 1
.bullet4_done
	rts
        
